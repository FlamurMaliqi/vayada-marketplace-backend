name: Build and Push to ECR

on:
  push:
    branches:
      - main

env:
  AWS_REGION: eu-west-1
  ECR_REPOSITORY: vayada-creator-marketplace-backend
  AWS_ACCOUNT_ID: 269416271598

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: vayada_user
          POSTGRES_PASSWORD: vayada_password
          POSTGRES_DB: vayada_db
        options: >-
          --health-cmd "pg_isready -U vayada_user -d vayada_db"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      auth-postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: vayada_auth_user
          POSTGRES_PASSWORD: vayada_auth_password
          POSTGRES_DB: vayada_auth_db
        options: >-
          --health-cmd "pg_isready -U vayada_auth_user -d vayada_auth_db"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5435:5432
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Wait for PostgreSQL
        run: |
          echo "Waiting for PostgreSQL to be ready..."
          for i in {1..30}; do
            if PGPASSWORD=vayada_password psql -h localhost -U vayada_user -d vayada_db -c '\q' 2>/dev/null; then
              echo "PostgreSQL is ready!"
              break
            fi
            echo "Attempt $i/30: Waiting for PostgreSQL..."
            sleep 2
          done
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: vayada_user
          PGPASSWORD: vayada_password
      
      - name: Create test database
        run: |
          PGPASSWORD=vayada_password psql -h localhost -U vayada_user -d vayada_db -c "CREATE DATABASE vayada_test_db;" || echo "Database might already exist"
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: vayada_user
          PGPASSWORD: vayada_password
      
      - name: Set up auth database schema
        run: |
          echo "Waiting for auth PostgreSQL..."
          for i in {1..30}; do
            if PGPASSWORD=vayada_auth_password psql -h localhost -p 5435 -U vayada_auth_user -d vayada_auth_db -c '\q' 2>/dev/null; then
              echo "Auth PostgreSQL is ready!"
              break
            fi
            echo "Attempt $i/30: Waiting..."
            sleep 2
          done
          echo "Running auth DB schema..."
          PGPASSWORD=vayada_auth_password psql -h localhost -p 5435 -U vayada_auth_user -d vayada_auth_db <<'EOSQL'
          CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
          CREATE TABLE IF NOT EXISTS public.users (
            id uuid NOT NULL DEFAULT uuid_generate_v4(),
            email text NOT NULL UNIQUE,
            password_hash text NOT NULL,
            name text NOT NULL,
            type text NOT NULL CHECK (type = ANY (ARRAY['hotel','creator','admin'])),
            status text NOT NULL DEFAULT 'pending' CHECK (status = ANY (ARRAY['pending','verified','rejected','suspended'])),
            avatar text,
            email_verified boolean NOT NULL DEFAULT false,
            terms_accepted_at timestamp with time zone,
            privacy_accepted_at timestamp with time zone,
            terms_version text,
            privacy_version text,
            marketing_consent boolean DEFAULT false,
            marketing_consent_at timestamp with time zone,
            created_at timestamp with time zone NOT NULL DEFAULT now(),
            updated_at timestamp with time zone NOT NULL DEFAULT now(),
            CONSTRAINT users_pkey PRIMARY KEY (id)
          );
          CREATE TABLE IF NOT EXISTS public.password_reset_tokens (
            id uuid NOT NULL DEFAULT uuid_generate_v4() PRIMARY KEY,
            user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
            token text NOT NULL UNIQUE,
            expires_at timestamp with time zone NOT NULL,
            used boolean NOT NULL DEFAULT false,
            created_at timestamp with time zone NOT NULL DEFAULT now()
          );
          CREATE TABLE IF NOT EXISTS public.email_verification_codes (
            id uuid NOT NULL DEFAULT uuid_generate_v4() PRIMARY KEY,
            email text NOT NULL,
            code text NOT NULL,
            expires_at timestamp with time zone NOT NULL,
            used boolean NOT NULL DEFAULT false,
            created_at timestamp with time zone NOT NULL DEFAULT now()
          );
          CREATE TABLE IF NOT EXISTS public.email_verification_tokens (
            id uuid NOT NULL DEFAULT uuid_generate_v4() PRIMARY KEY,
            user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
            token text NOT NULL UNIQUE,
            expires_at timestamp with time zone NOT NULL,
            used boolean NOT NULL DEFAULT false,
            created_at timestamp with time zone NOT NULL DEFAULT now()
          );
          CREATE TABLE IF NOT EXISTS public.cookie_consent (
            id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
            visitor_id text NOT NULL,
            user_id uuid REFERENCES users(id) ON DELETE CASCADE,
            necessary boolean DEFAULT true NOT NULL,
            functional boolean DEFAULT false NOT NULL,
            analytics boolean DEFAULT false NOT NULL,
            marketing boolean DEFAULT false NOT NULL,
            created_at timestamp with time zone DEFAULT now() NOT NULL,
            updated_at timestamp with time zone DEFAULT now() NOT NULL
          );
          CREATE TABLE IF NOT EXISTS public.consent_history (
            id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id uuid REFERENCES users(id) ON DELETE CASCADE,
            consent_type text NOT NULL,
            consent_given boolean NOT NULL,
            version text,
            ip_address text,
            user_agent text,
            created_at timestamp with time zone DEFAULT now() NOT NULL
          );
          CREATE TABLE IF NOT EXISTS public.gdpr_requests (
            id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id uuid REFERENCES users(id) ON DELETE SET NULL NOT NULL,
            request_type text NOT NULL,
            status text NOT NULL DEFAULT 'pending',
            requested_at timestamp with time zone DEFAULT now() NOT NULL,
            processed_at timestamp with time zone,
            expires_at timestamp with time zone,
            download_token text,
            cancellation_reason text,
            ip_address text,
            CONSTRAINT valid_request_type CHECK (request_type IN ('export', 'deletion')),
            CONSTRAINT valid_status CHECK (status IN ('pending', 'processing', 'completed', 'cancelled', 'expired'))
          );
          EOSQL

      - name: Run database migrations
        run: |
          # Verify test database is ready
          echo "Verifying test database connection..."
          PGPASSWORD=vayada_password psql -h localhost -U vayada_user -d vayada_test_db -c '\q'

          # Run migrations using the migration script
          echo "Running migrations..."
          PYTHONPATH=. python scripts/run_migrations.py
        env:
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: vayada_user
          PGPASSWORD: vayada_password
          DATABASE_URL: postgresql://vayada_user:vayada_password@localhost:5432/vayada_test_db
          AUTH_DATABASE_URL: postgresql://vayada_auth_user:vayada_auth_password@localhost:5435/vayada_auth_db
          PYTHONPATH: .
          CORS_ORIGINS: "http://localhost:3000,http://localhost:3001"
          EMAIL_ENABLED: "true"
          DEBUG: "true"
          JWT_SECRET_KEY: "test-secret-key-for-testing-only"
          FRONTEND_URL: "http://localhost:3000"
      
      - name: Check for test files
        id: check_tests
        run: |
          if find tests -name "test_*.py" -o -name "*_test.py" | grep -q .; then
            echo "has_tests=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Test files found"
          else
            echo "has_tests=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  No test files found - skipping tests"
          fi
      
      - name: Run tests
        if: steps.check_tests.outputs.has_tests == 'true'
        run: |
          PYTHONPATH=. pytest tests/ -v --tb=short
        env:
          DATABASE_URL: postgresql://vayada_user:vayada_password@localhost:5432/vayada_test_db
          AUTH_DATABASE_URL: postgresql://vayada_auth_user:vayada_auth_password@localhost:5435/vayada_auth_db
          TEST_DATABASE_URL: postgresql://vayada_user:vayada_password@localhost:5432/vayada_test_db
          EMAIL_ENABLED: "true"
          DEBUG: "true"
          JWT_SECRET_KEY: "test-secret-key-for-testing-only"
          FRONTEND_URL: "http://localhost:3000"
          CORS_ORIGINS: "http://localhost:3000,http://localhost:3001"

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: test  # Only deploy if tests pass
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for amd64
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:latest
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Output image URI
        run: |
          echo "Image pushed successfully!"
          echo "Latest: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:latest"
          echo "Commit SHA: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ github.sha }}"

      - name: Deploy to ECS
        run: |
          echo "üöÄ Deploying to ECS..."
          aws ecs update-service \
            --cluster vayada-backend-cluster \
            --service vayada-backend-service \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ ECS deployment triggered!"
          echo "   The service will pull the latest image and deploy it."
          echo "   Monitor deployment: aws ecs describe-services --cluster vayada-backend-cluster --services vayada-backend-service --region ${{ env.AWS_REGION }}"
